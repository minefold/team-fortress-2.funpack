#!/usr/bin/env ruby
require 'time'
require 'json'
require 'open3'

$:.unshift File.expand_path('../../lib', __FILE__)

require 'log_processor'
require 'settings'

# ---

STDOUT.sync = true
$stdin.sync = true

# usage: ./run <config>

config_path = ARGV.shift
build_dir = ENV['BUILD_DIR']
root = File.expand_path('../..', __FILE__)

config = JSON.parse(File.read(config_path))

server_id = 2
default_cfg = "#{build_dir}/orangebox/tf/cfg/server.cfg"
server_cfg = "#{build_dir}/orangebox/tf/cfg/server-#{server_id}.cfg"

system %Q{
rm -f #{default_cfg}
echo "440" > #{build_dir}/orangebox/steam_appid.txt
}

s = Settings.new(config['settings'])
File.write(server_cfg, s.erb(File.read("#{root}/templates/server.cfg.erb")))

Dir.chdir("#{build_dir}/orangebox") do
  Open3.popen3("./srcds_run",
          "-autoupdate",
          # "-console",
          "-verify_all",
          "-secure",
          "-game", "tf",
          "-nobrakepad",
          "-pingboost", "2",
          "+hostname", "tf2/whatupdave",
          "+sv_lan", "0",
          "+hostport", config['port'].to_s,
          "+map", `cat #{build_dir}/orangebox/tf/mapcycle.txt | sort -R | head -n1`.strip,
          "+maxplayers", "24",
          "+fps_max", "300",
          "+exec", "server-#{server_id}.cfg") do |stdin, stdout, stderr, wait_thr|

    processor = LogProcessor.new

    begin
      # read stdin. On list command we call partylist
      # which is a custom plugin designed to return the real player names
      # instead of nicknames
      Thread.new do
        while true
          input = $stdin.readline.strip
          case input
          when 'list'
            stdin.puts('users')
          when /^kick (.*)$/
            stdin.puts("kickid #{$1}")
          else
            stdin.puts(input)
          end
        end
      end

      # flush the output stream
      Thread.new do
        stdin.puts
        sleep 3
      end

      while true
        event = processor.process_line(stdout.readline)
        puts JSON.dump(event) if event
      end
    rescue EOFError
    end
    exit_status = wait_thr.value
  end
end